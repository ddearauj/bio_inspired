import math
from random import randint
from random import sample as random_sample
from population import Population



# things I need to check on the code
#   How to change the cell in the for loop
#   is the delta exp(-fit) or exp(fit)

class MNIST_Cell():

    def __init__(self, model, digit):
        self.model  = model
        self.digit  = digit
        self.pixels = get_initial_pixels()

    def get_initial_pixels():
        # first randomly generate the pixel value for the 784 pixels
        # since our model trained with normalized values, we generate pixels from 0 to 1
        pixel_list = np.random.uniform(0,1,784)
        return pixel_list.reshape(1,1,28,28)
    

    def calculate_fitness(self):
        self.fitness = self.model.predict_proba(self.pixels)[digit]





class CobAINet_Population(Population):
    """update constructor to inherit from population"""

    def __init__(self, population, mutation_prob, crossover_prob, crossover_type="sexual", supression_radious):
        self.population = population  # list containing the antibodies objects
        self.max_size = len(population)
        self.affinity_matrix # this will be a numpy 2D array
        # self.antibodies      # list containing the antibodies objects


        # those are constants that are used through the simulation
        # in C they were defined. Need to find a better way to represent them
        self.supression_radious = supression_radious
        self.max_clones
        self.min_clones
        self.final_beta
        self.initial_beta
        self.max_iterations
        self.current_beta
        self.initial_concentration

    def calculate_fitness(self):
        for individual in self.population:
            individual.calculate_fitness()


    def mutate(self):
        for individual in self.population:
            if randint(0, 100) <= self.mutation_prob:
                individual.mutate()


    def sort_pop(self):
        self.population.sort(key=lambda x: x.fitness, reverse=True)



    def update_affinity(self):
        """ Updates the affinity between each cell in the imuno system """

        total_concentration = 0

        # iterating though a numpy array
        affinity_matrix = np.empty([self.max_size, self.max_size])


        # this is wasteful
        # it is a symmetric matrix. I don't need to iterate over all the antibodies...
        # should update to a pythonic version of:
        # 
        # for (i = 0; i < size; i++) {
        #     for (j = i ; j < size; j++) {
        #         affinity_matrix[i][j] = distance(population[i], population[j]);
        #     }
        # }
        #
        # for (j = 0; j < size; j++) {
        #     for (i = j; i < size; i++) {
        #         affinity_matrix[i][j] = affinity_matrix[j][i];
        #     }
        # }
        
        for i,j in np.ndindex(affinity_matrix.shape):
            affinity_matrix[i,j] = population[i].distance(population[j])

        # after we calculate the distance in the antibodies, we update the value 
        # I took this from the PhD dissertation from a guy in the lab. It is in portuguse, though. I believe the english version is this paper:
        # https://ieeexplore.ieee.org/abstract/document/5949758
        # na hora de documentar, colocar o calculo e explicação do que é de fato a afinidade entre duas celulas


        for i,j in np.ndindex(affinity_matrix.shape):
            if (affinity_matrix[i,j] <= self.supression_radious and i != j):
                affinity_matrix[i,j] = self.population[j].concentration * (supression_radious - affinity_matrix[i,j])
            else:
                affinity_matrix[i,j] = 0


        # now we calculate the total affinity of the cell i and all the other cells in the population
        # because I want to reset the values only with new cell_i and not at every i,j loop
        # I will do this loop in a C like fashion. Will look for a pythonic way later
        for i in range(self.max_size):
            population[i].total_affinity = 0
            total_cell_concentration = 0
            
            for j in range(self.max_size):
                if (self.population[i].fitness <= self.population[j].fitness and i !=j):
                    population[i].total_affinity += affinity_matrix[i,j]
                    total_cell_concentration += population[j].concentration

            if total_cell_concentration > 0:
                population[i].total_affinity = population[i].total_affinity/somaconcentracao

            else: # in this case the set J is empty, so no affinity between cell i and the population
                population[i].total_affinity = 0

    def clone(self):

        clone_counter = 0 # it will count the number of clones generated by each cell

        self.sort_pop()

        for cell in self.population:
            n_clones = cell.concentratiton * (self.max_clones - self.min_clones) + min_clones
            # each cell will have a number os clones generated depending on their concentration

            for i in range(n_clones//1): # round the number of clones down to the closest integer

            # the clones will be the copy of the cell added a litte randomness.
            # this randomness is treated by the cell object
            # for instance, it will deal with restrictions and etc.

            clone = cell.copy()
            delta = (1/self.current_beta * math.exp()) # fitness ou - fitness?
            clone.add_perturb(delta)

            # decide if the clone should compete with parent or not based on the supression radius and population size

            if cell.distance(clone) > self.supression_radious and self.max_size < len(self.population):
                clone.concentration = self.initial_concentration
                self.population.append(clone)

            else:
                # if the clone is better, clone will take the parents place
                if clone.calculate_fitness() > cell.fitness:

                    
                    cell = clone # can I do this change here? Will it be affected?



    def eliminate_zero_concentration_cells(self):
        self.population = [pop for pop in self.population if pop.concentration > 0]


    def _update_beta(iteration):
        """ Returns a updated value for beta, as it decays through the iterations """
        self.current_beta = ((self.initial_beta - self.final_beta) / (1 + math.exp((20/self.max_iterations) * (iteration - self.max_iterations/2)))) + self.final_beta





def cob_ai_net(population, initial_beta=3, final_beta=0.001):

    beta = initial_beta
    pop.calculate_fitness()
    affinity()

    for i in iterations:
        
        if i % update_beta_in == 0:
            beta = update_beta()

        clone()
        mutate()
        select()
        fitness()
        affinity()
        update_concentration()
        eliminate()
        affinity()